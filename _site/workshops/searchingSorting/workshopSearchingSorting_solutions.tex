\documentclass{exam} 
\printanswers 
\def\workshopTitle{Workshop - Searching Sorting} 
\input{comp125workshopHeader}
\section* {Learning outcomes}

The learning outcomes of this workshop are to improve your understanding of searching and sorting algorithms.

\begin{center}
\fbox{
\begin{minipage}{0.8\textwidth}
Import project from \texttt{workshopSearchingSortingTemplate.zip}. 
\end{minipage}
}
\end{center}

\begin{questions}

\vskip 0.5 cm 
\question  \textbf{Selection sort trace} \vskip 0.5cm

\begin{parts}
\part What is the status of the array \texttt{arr} at the end of each \emph{iteration} while sorting it in \textbf{descending} order using selection sort (when sorting from left to right). The original array \texttt{arr} is $\{6, 1, 3, 8, 2, 5, 9\}$

\begin{solution}
\begin{verbatim}
6 1 3 8 2 5 9
9 1 3 8 2 5 6
9 8 3 1 2 5 6
9 8 6 1 2 5 3
9 8 6 5 2 1 3
9 8 6 5 3 1 2
9 8 6 5 3 2 1
\end{verbatim}
\end{solution}

\part What is the status of the array \texttt{arr} at the end of each \emph{iteration} while sorting it in \textbf{descending} order using selection sort (when sorting from \textbf{right} to \textbf{left}). The original array \texttt{arr} is $\{6, 1, 3, 8, 2, 5, 9\}$

\begin{solution}
\begin{verbatim}
6 1 3 8 2 5 9
6 9 3 8 2 5 1
6 9 3 8 5 2 1
6 9 5 8 3 2 1
6 9 8 5 3 2 1
8 9 6 5 3 2 1
9 8 6 5 3 2 1
\end{verbatim}
\end{solution}

\part What is the status of the array \texttt{arr} at the end of each \emph{iteration} while sorting it in \textbf{ascending} order of \textbf{number of digits} using selection sort (when sorting from \textbf{left} to \textbf{right}). The original array \texttt{arr} is $\{125, 10, 9, 20, 300, 2\}$

\begin{solution}
\begin{verbatim}
125 10 9 20 300 2
9 10 125 20 300 2
9 2 125 20 300 10
9 2 20 125 300 10
9 2 20 10 300 125
9 2 20 10 300 125

\end{verbatim}
\end{solution}
\end{parts}

\vskip 0.5cm
\question  \textbf{Insertion sort trace} \vskip 0.5cm

Write an answer to question 1, but for insertion sort instead of selection sort.

\begin{solution}
Descending Left to right -
\begin{verbatim}
6 1 3 8 2 5 9
6 1 3 8 2 5 9
6 3 1 8 2 5 9
8 6 3 1 2 5 9
8 6 3 2 1 5 9
8 6 5 3 2 1 9
9 8 6 5 3 2 1
\end{verbatim}

Descending Right to left -
\begin{verbatim}
6 1 3 8 2 5 9
6 1 3 8 2 9 5
6 1 3 8 9 5 2
6 1 3 9 8 5 2
6 1 9 8 5 3 2
6 9 8 5 3 2 1
9 8 6 5 3 2 1
\end{verbatim}

Ascending Left to right -
\begin{verbatim}
125 10 9 20 300 2
10 125 9 20 300 2
9 10 125 20 300 2
9 10 20 125 300 2
9 10 20 125 300 2
9 2 10 20 125 300
\end{verbatim}
\end{solution}

\vskip 0.5 cm \question  Complete the method \texttt{sortNumDigits} in class \texttt{SortService} that sorts an array of integers in the order of number of digits. For example, if the array before sorting is $\{21, 8, 923, 16, 457, 9\}$, after sorting it should be $\{8, 9, 21, 16, 923, 457\}$. 

You should add a helper method that returns the number of digits in the integer passed. 

\begin{solution}
Assuming helper method is \texttt{nDigits(int)} that returns the number of digits in the passed integer,  \texttt{FIXME} will be replaced by \texttt{nDigits(data[k]) > nDigits(backup)}.

Pease refer to the completed method in the solutions project.
\end{solution}

\question \textbf{Binary search trace}

Trace the execution of the binary search method from the lecture notes for the array, 
\begin{verbatim}
{1, 4, 5, 7, 9, 23, 47, 50, 58, 58, 58, 59, 88, 90, 95, 99}
\end{verbatim}

and each of the following targets:

\begin{enumerate}
  \item \texttt{target} = 50
  \item \texttt{target} = 58
  \item \texttt{target} = 2
\end{enumerate}

Your trace must be shown in the form of a logic table with the following structure:
\vskip 0.5cm

\small
\begin{tabular}{c | c | c | c | c | c | c} 
\hline
first &	last &	first <= last & median & arr[median] & target (== or > or <) arr[median] & return value\\
\hline
& & & & & & \\
\hline
\end{tabular}
\normalsize
\vskip 0.5cm

\begin{solution}
\small
target = 50:
\vskip 0.2cm
\begin{tabular}{c | c | c | c | c | c | c} 
\hline
first &	last &	first <= last & median & arr[median] & target (== or > or <) arr[median] & return value\\
\hline
0 & 15 & true & 7 & 50 & == & 7\\
\hline
\end{tabular}
\vskip 0.5cm
	
target=58:
\vskip 0.2cm
\begin{tabular}{c | c | c | c | c | c | c} 
\hline
first &	last &	first <= last & median &	 arr[median] & target (== or > or <) arr[median] & return value\\
\hline
0 & 15 & true & 7 & 50 & 58 > 50 & \\
8 & 15 & true & 11 & 59 & 58 < 59 & \\
8 & 10 & true & 9 & 58 & 58 == 59 & 9\\
\hline
\end{tabular}
\vskip 0.5cm

target = 2:
\vskip 0.2cm
\begin{tabular}{c | c | c | c | c | c | c} 
\hline
first &	last &	first <= last & median & arr[median] & target (== or > or <) arr[median] & return value\\
\hline
0 & 15 & true & 7 & 50 & 2 < 50 & \\
0 & 6 & true & 3 & 7 & 2 < 7 & \\
0 & 2 & true & 1 & 4 & 2 < 4 & \\
0 & 0 & true & 0 & 1 & 2 > 1 & \\
1 & 0 & false & 0 & 1 & 2 > 1 & -1\\
\hline
\end{tabular}
\normalsize
\end{solution}

\question \textbf{Tweak binary search}

What changes must you make to the binary search method from the lecture notes if the array is sorted in \textbf{descending} order instead? Explain your answer in 3-4 lines or by using an example.

\begin{solution}
The only change required is changing the line

\begin{lstlisting}
if(target > arr[median])
\end{lstlisting}

to 

\begin{lstlisting}
if(target < arr[median])
\end{lstlisting}

This reflects shifting of search space to right half for items smaller than target instead of items bigger than target.
\end{solution}

\question \textbf{Binary search on array of objects}

Complete the \texttt{binarySearch} method in class\texttt{SearchService} that searches of a target \texttt{Rectangle} in an array of \texttt{Rectangle} objects sorted based on area. Note that if target is a rectangle of 4 by 5, all rectangles with the same area (20) are considered to be matches since the searching and sorting criteria is area.

\begin{solution}
Please refer to the solutions project for completed solution.	
\end{solution}

\end{questions}

\newpage

\section*{Extra questions for take-home exercises}

\begin{questions}
\question  \textbf{Importance of deep learning - debugging sorting algorithm} \vskip 0.5cm

The method \texttt{selectionSortBuggy} in class \texttt{Buggy.java} contains some bugs (duh!).
A client is provided in \texttt{BuggySortClient.java} that calls the said method but the array remains unsorted. Identify the bug in \texttt{selectionSortBuggy} with the help of drawing a memory diagram and logic table, and fix it. \textbf{TIP: Note all memory transactions.}

\begin{solution}
The problem is with the way the items are being swapped. In its current version, a copies of the items that should be swapped are made, and it's the copies that are swapped.
	
You must swap the array items, accessed through their indices.	

Please refer to the solutions project for the corrected code.
\end{solution}	

\vskip 0.5 cm 

\question  Complete the method \texttt{sortNumberOfDivisors} in class \texttt{SortService} that sorts an array of integers in the order of number of non-trivial divisors (divisors other than 1 and the number itself). For example, 15 has 2 non-trivial divisors - 3 and 5. For example, if the array before sorting is $\{24, 1, 65, 31, 25\}$, after sorting it should be $\{1, 31, 25, 65, 24\}$. 

You should add a helper method that returns the number of divisors of the integer passed. 

\begin{solution}
\begin{lstlisting}[style=buggy]
public static void sortNumberOfDivisors(int[] a) {
	if(a == null) 
		return;
	for(int i=1; i < a.length; i++) {
		int backup = a[i];
		int k = i - 1;
		while(k >= 0 && @nDivisors(a[k]) > nDivisors(backup)@) {
			a[k+1] = a[k];
			k--;
		}
		a[k+1] = backup;
	}
}

public static int nDivisors(int n) {
	n = Math.abs(n); //in case negative
	int count = 0;
	for(int i=2; i < n; i++) {
		if(n%i == 0) { //another divisor
			count++;
		}
	}//end loop
	return count;
}	
\end{lstlisting}
\end{solution}

\vskip 0.5 cm \question Complete the method \texttt{secondarySort} \vskip 0.5cm
The method \texttt{secondarySort} in class \texttt{FractionArrayService}, is a slight variation of insertion sort, and sorts a \texttt{Fraction} array by putting each item of array at the rightful place \emph{so far} in a secondary array. The original array should then be manipulated so that each item of the old array refers to the object the corresponding item of the secondary array refers to. This step has been left incomplete in the template and your job is to complete this part. You are trying to go through each item of the passed array (the array that needs to be sorted) (using index $i$) and updating its reference to the item at the same index in the secondary array.

\begin{solution}
Re-referencing the array as \texttt{fractions = temp;} doesn't work as any re-referencing applied to a parameter array is ignored upon exiting the method. Hence, we need to re-reference each item of the array individually.
\begin{lstlisting}
for(int i=0; i<temp.length; i++)
	fractions[i] = temp[i];
\end{lstlisting}
\end{solution}

\question \textbf{(ADVANCED): Graph validity} \vskip 0.5cm

In graph theory, it is possible to draw a (simple) graph only if,

\begin{enumerate}
\item if the sum of edges is even.
\item none of the vertices has a degree greater than or equal to the number of vertices.
\item the graph remains valid after removing all (say $k$) edges of the \emph{most connected} vertex (and one from other $k$ vertices each). While repeating this procedure, an unconnected vertex can be ignored. Only if we reach an empty graph by repeatedly applying this step, is it a valid graph. If we reach a scenario where the most connected vertex has degree $k$ and there aren't $k$ other vertices with non-zero degree left, the graph is invalid.
\end{enumerate}

For example, if the degree (number of edges with the vertex as an end-point) set for the vertices of a graph is \{3, 3, 3, 3, 3\}, we can see that the sum of degrees is 15 (not even), therefore it's not a valid graph.

If the degree (number of edges with the vertex as an end-point) set for the vertices of a graph is \{3, 3, 10, 4, 2\}, the third vertex's degree (10) is invalid (max degree for a graph with 5 vertices is 4), therefore it's not a valid graph.

If the degree (number of edges with the vertex as an end-point) set for the vertices of a graph is \{3, 3, 2, 4, 2\}, the first two aspects are ok (no violation). The sorted set is \{4,3,3,2,2\}, and after removing the 4 edge connected to the first vertex, the set becomes \{2,2,1,1\} (first vertex is disconnected and can be ignored. Repeating the process, the set becomes \{1,1,0,0\}, which is \{1,1\}, which becomes \{0,0\}, which is an empty graph. Hence the original graph is valid.

Similarly, if the set is \{4,3,2,2,1\}

\begin{align*}
\{4,3,2,2,1\}\\
reduced: \{0,2,1,1,0\}\\
sorted: \{2,1,1,0,0\}\\
reduced: \{0,0,0,0,0\}\\
valid \quad (empty \quad graph \quad reached)
\end{align*}

Another example - if the set is \{2,5,2,4,3,4\},

\begin{align*}
\{2,5,2,4,3,4\}\\
sorted: \{5,4,4,3,2,2\}\\
reduced: \{0,3,3,2,1,1\}\\
sorted: \{3,3,2,1,1,0\}\\
reduced: \{0,2,1,0,1,0\}\\
sorted: \{2,1,1,0,0,0\}\\
reduced: \{0,0,0,0,0,0\}\\
valid
\end{align*}

Last example - if the set is \{3,3,3,3\},

Similarly, if the set is \{2,5,2,5,3,4\},

\begin{align*}
\{5,5,4,3,2,2\}\\
reduced: \{0,4,3,2,1,1\}\\
invalid \quad (odd \quad sum \quad of \quad degrees)
\end{align*}

Write a method that when passed an array of degrees of the vertices of a graph, returns \texttt{true} if it's a valid graph, and \texttt{false} otherwise. Header of the method provided below:

\begin{lstlisting}
public static boolean isValidGraph(int[] degrees)
\end{lstlisting}

\begin{solution}
Refer to \texttt{GraphService.java} in the solution project	
\end{solution}
\end{questions}
\end{document}
