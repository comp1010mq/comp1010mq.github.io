\usepackage[T1]{fontenc}
\usepackage{pslatex}
%\usepackage[pdftex]{color}  
%\usepackage[pdftex]{graphicx}     
\usepackage{verbatim}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{paralist}
\usepackage{tagging}
\usepackage{amsmath}

\usepackage[colorlinks=true,urlcolor=red]{hyperref}
\setlength{\topmargin}{-0.5in}                  % topmargin now at 1in
\setlength{\textheight}{9.5in}                  % body of text = 9.5in
\setlength{\oddsidemargin}{0in}                 % left margin = 1.0in on odd-numbered pages
\setlength{\evensidemargin}{0in}                % left margin = 1.0in on even-numbered pages 
\setlength{\textwidth}{6.5in}                   % width of text line.
\setlength{\parindent}{0.0in}

\lstset{%
	language=Java,
	basicstyle=\footnotesize\ttfamily,
	numbers=left,
	numberstyle=\tiny,        
	xleftmargin=17pt,
        	xrightmargin=5pt,
	frame=single,
	breaklines=true,
}

\lstdefinestyle{buggy}{
  language=Java,
  emptylines=1,
  breaklines=true,
  basicstyle=\ttfamily\color{black},
  moredelim=**[is][\color{red}]{@}{@},
}

\lstdefinestyle{correct}{
  language=Java,
  emptylines=1,
  breaklines=true,
  basicstyle=\ttfamily\color{black},
  moredelim=**[is][\color{blue}]{@}{@},
}

\usepackage[colorlinks=true,urlcolor=red]{hyperref}
\setlength{\topmargin}{-0.5in}                  % topmargin now at 1in
\setlength{\textheight}{9.5in}                  % body of text = 9.5in
\setlength{\oddsidemargin}{0in}                 % left margin = 1.0in on odd-numbered pages
\setlength{\evensidemargin}{0in}                % left margin = 1.0in on even-numbered pages 
\setlength{\textwidth}{6.5in}                   % width of text line.
\setlength{\parindent}{0.0in}
\newcommand{\code}{\texttt}

\usepackage{listings}
\lstset{%
	language=Java,
	basicstyle=\footnotesize\ttfamily,
	numbers=left,
	numberstyle=\tiny,        
	xleftmargin=17pt,
        	xrightmargin=5pt,
	frame=single,
	breaklines=true,
	moredelim=\item \item [is][\color{red}]{@}{@}
}

\begin{document}

\definecolor{aquamarine}{rgb}{0,0,0.7}
\definecolor{blue}{rgb}{0,0,0.7}
\definecolor{red}{rgb}{1,0,0}

%
\vspace{0.2in}
\begin{center}
        {\large  %MACQUARIE UNIVERSITY\\
%\medskip
\includegraphics[scale=0.3]{mqlogo.jpeg}\\
\medskip
        {\it  Faculty of Science and Engineering\\}
        \vspace{0.2in}
         {\bf COMP125 Fundamentals of Computer Science\\
        Workshop - Sorting\\}}
\end{center}
\vspace{0.3in}
%

%\renewcommand{\labelenumi}{\arabic{enumi}.}
\renewcommand{\labelenumi}{\alph{enumi}.}
 
\section* {Learning outcomes}

By the end of this session, you will have learnt about dealing with arrays of objects, and more specifically sorting them. 

\begin{center}
\fbox{
\begin{minipage}{0.8\textwidth}
Import project from \texttt{workshop\_sorting\_template.zip}. 
\end{minipage}
}
\end{center}

\begin{questions}

\vskip 0.5 cm 
\question  \textbf{Selection sort trace} \vskip 0.5cm

\begin{parts}
\part What is the status of the array \texttt{arr} at the end of each \emph{iteration} while sorting it in \textbf{descending} order using selection sort (when sorting from left to right). The original array \texttt{arr} is $\{6, 1, 3, 8, 2, 5, 9\}$

\begin{solution}
\begin{verbatim}
6 1 3 8 2 5 9
9 1 3 8 2 5 6
9 8 3 1 2 5 6
9 8 6 1 2 5 3
9 8 6 5 2 1 3
9 8 6 5 3 1 2
9 8 6 5 3 2 1
\end{verbatim}
\end{solution}

\part What is the status of the array \texttt{arr} at the end of each \emph{iteration} while sorting it in \textbf{descending} order using selection sort (when sorting from \textbf{right} to \textbf{left}). The original array \texttt{arr} is $\{6, 1, 3, 8, 2, 5, 9\}$

\begin{solution}
\begin{verbatim}
6 1 3 8 2 5 9
6 9 3 8 2 5 1
6 9 3 8 5 2 1
6 9 5 8 3 2 1
6 9 8 5 3 2 1
8 9 6 5 3 2 1
9 8 6 5 3 2 1
\end{verbatim}
\end{solution}

\part What is the status of the array \texttt{arr} at the end of each \emph{iteration} while sorting it in \textbf{ascending} order of \textbf{number of digits} using selection sort (when sorting from \textbf{left} to \textbf{right}). The original array \texttt{arr} is $\{125, 10, 9, 20, 300, 2\}$

\begin{solution}
\begin{verbatim}
125 10 9 20 300 2
9 10 125 20 300 2
9 2 125 20 300 10
9 2 20 125 300 10
9 2 20 10 300 125
9 2 20 10 300 125

\end{verbatim}
\end{solution}
\end{parts}

\vskip 0.5cm
\question  \textbf{Insertion sort trace} \vskip 0.5cm

Write an answer to question 1, but for insertion sort instead of selection sort.

\begin{solution}
Descending Left to right -
\begin{verbatim}
6 1 3 8 2 5 9
6 1 3 8 2 5 9
6 3 1 8 2 5 9
8 6 3 1 2 5 9
8 6 3 2 1 5 9
8 6 5 3 2 1 9
9 8 6 5 3 2 1
\end{verbatim}

Descending Right to left -
\begin{verbatim}
6 1 3 8 2 5 9
6 1 3 8 2 9 5
6 1 3 8 9 5 2
6 1 3 9 8 5 2
6 1 9 8 5 3 2
6 9 8 5 3 2 1
9 8 6 5 3 2 1
\end{verbatim}

Ascending Left to right -
\begin{verbatim}
125 10 9 20 300 2
10 125 9 20 300 2
9 10 125 20 300 2
9 10 20 125 300 2
9 10 20 125 300 2
9 2 10 20 125 300
\end{verbatim}
\end{solution}

\vskip 0.5 cm 

\question  \textbf{Importance of deep learning - debugging sorting algorithm} \vskip 0.5cm

The method \texttt{selectionSortBuggy} in class \texttt{Buggy.java} contains some bugs (duh!).
A client is provided in \texttt{BuggySortClient.java} that calls the said method but the array remains unsorted. Identify the bug in \texttt{selectionSortBuggy} with the help of drawing a memory diagram and logic table, and fix it. \textbf{TIP: Note all memory transactions.}

\begin{solution}
The problem is with the way the items are being swapped. In its current version, a copies of the items that should be swapped are made, and it's the copies that are swapped.

\begin{lstlisting}[style=buggy]
public static void selectionSortBuggy(int[] arr) {
	if(arr == null)
		return; //nothing to do
		
	for(int i=0; i < arr.length - 1; i++) {
		int minIndex = smallestItemIndex(arr, i);
		
		@int first = arr[i];@
		@int second = arr[minIndex];@
		
		@int temp = first;@
		@first = temp;@
		@temp = second;@
	}
}
\end{lstlisting}	
	
You must swap the array items, accessed through their indices.	

\begin{lstlisting}[style=correct]
public static void selectionSortBuggy(int[] arr) {
	if(arr == null)
		return; //nothing to do
		
	for(int i=0; i < arr.length - 1; i++) {
		int minIndex = smallestItemIndex(arr, i);
		
		@int temp = arr[i];@
		@arr[i] = arr[minIndex];@
		@arr[minIndex] = second;@
	}
}
\end{lstlisting}
\end{solution}

%\vskip 0.5 cm \question  \textbf{\texttt{bubbleSort}} \vskip 0.5cm
%
%\begin{parts}
%
%
%\part Trace the execution of the method \texttt{bubbleSort(Fraction[])} in class \texttt{FractionArrayService} for the \texttt{myFractions} created as,
%
%\begin{lstlisting}
%int[] nums = {5, 10, 2, 100, 6};
%int[] dens = {2, 20, 5, 100, 5};
%myFractions = new Fraction[5];
%for(int i=0; i<myFractions.length; i++) {
%	myFractions[i] = new Fraction(nums[i], dens[i]);
%}
%\end{lstlisting}
%
%\begin{solution}
%\begin{verbatim}
%i=0	{5/2, 10/20, 2/5, 100/100, 6/5}
%	k=0	{10/20, 5/2, 2/5, 100/100, 6/5}
%	k=1	{10/20, 2/5, 5/2, 100/100, 6/5}
%	k=2	{10/20, 2/5, 100/100, 5/2, 6/5}
%	k=3	{10/20, 2/5, 100/100, 6/5, 5/2}
%		
%i=1	{10/20, 2/5, 100/100, 6/5, 5/2}
%	k=0	{2/5, 10/20, 100/100, 6/5, 5/2}
%	k=1	{2/5, 10/20, 100/100, 6/5, 5/2}
%	k=2	{2/5, 10/20, 100/100, 6/5, 5/2}
%
%i=2	{2/5, 10/20, 100/100, 6/5, 5/2}
%	k=0	{2/5, 10/20, 100/100, 6/5, 5/2}
%	k=1	{2/5, 10/20, 100/100, 6/5, 5/2}
%
%i=3	{2/5, 10/20, 100/100, 6/5, 5/2}	
%	k=0	{2/5, 10/20, 100/100, 6/5, 5/2}
%	
%Final array: {2/5, 10/20, 100/100, 6/5, 5/2}
%
%\end{verbatim}
%\end{solution}
%
%\part What are the best case and worst case time complexities of \texttt{bubbleSort}?
%
%\begin{solution}
%$B(n) = W(n) = O(n^2)$
%\end{solution}
%\end{parts}

\vskip 0.5 cm \question  Complete the method \texttt{sortNumDigits} that sorts an array of integers in the order of number of digits. You may, and probably should, add a helper method. For example, if the array before sorting is $\{54, 1, 45, 834, 91, 540\}$, after sorting it should be $\{1, 54, 45, 91, 834, 540\}$.

\begin{lstlisting}
public static void sortNumDigits(int[] a) {
	if(a == null) 
		return;
	for(int i=1; i < a.length; i++) {
		int backup = a[i];
		int k = i - 1;
		while(k >= 0 && _________________) {
			a[k+1] = a[k];
			k--;
		}
		a[k+1] = backup;
	}
}	
\end{lstlisting}

\begin{solution}
\begin{lstlisting}
public static void sortNumDigits(int[] a) {
	if(a == null) 
		return;
	for(int i=1; i < a.length; i++) {
		int backup = a[i];
		int k = i - 1;
		while(k >= 0 && @nDigits(a[k]) > nDigits(backup)@) {
			a[k+1] = a[k];
			k--;
		}
		a[k+1] = backup;
	}
}

public static int nDigits(int n) {
	int count = 0;
	while(n != 0) {
		count++;
		n/=10;
	} //end loop
	return count;
}	
\end{lstlisting}
\end{solution}

\vskip 0.5 cm \question  Complete the method \texttt{sortNumberOfDivisors} that sorts an array of integers in the order of number of non-trivial divisors (divisors other than 1 and the number itself). For example, 15 has 2 non-trivial divisors - 3 and 5. You may, and probably should, add a helper method. For example, if the array before sorting is $\{24, 1, 65, 31, 25\}$, after sorting it should be $\{1, 31, 25, 65, 24\}$.

\begin{lstlisting}
public static void sortNumberOfDivisors(int[] a) {
	if(a == null) 
		return;
	for(int i=1; i < a.length; i++) {
		int backup = a[i];
		int k = i - 1;
		while(k >= 0 && _________________) {
			a[k+1] = a[k];
			k--;
		}
		a[k+1] = backup;
	}
}	
\end{lstlisting}

\begin{solution}
\begin{lstlisting}[style=buggy]
public static void sortNumberOfDivisors(int[] a) {
	if(a == null) 
		return;
	for(int i=1; i < a.length; i++) {
		int backup = a[i];
		int k = i - 1;
		while(k >= 0 && @nDivisors(a[k]) > nDivisors(backup)@) {
			a[k+1] = a[k];
			k--;
		}
		a[k+1] = backup;
	}
}

public static int nDivisors(int n) {
	n = Math.abs(n); //in case negative
	int count = 0;
	for(int i=2; i < n; i++) {
		if(n%i == 0) { //another divisor
			count++;
		}
	}//end loop
	return count;
}	
\end{lstlisting}
\end{solution}

\vskip 0.5 cm

\question  \textbf{Fraction class} \vskip 0.5cm
Go through the class \texttt{Fraction} to understand its purpose. Instantiate a \texttt{Fraction} object to represent the fraction $\frac{12}{18}$. Draw a memory diagram to illustrate what happens in the memory when this object is instantiated. Reduce the fraction to its simplest form ( $\frac{2}{3}$).

\vskip 0.5 cm \question  \textbf{\texttt{compareTo(Fraction)} method} \vskip 0.5cm
Complete the method \texttt{compareTo} in class \texttt{Fraction}. The requirements for this method have been provided as javadoc comments above the method header. 

\begin{solution}
\begin{lstlisting}
public int compareTo(Fraction other) {
	if(equals(other))
		return 0;
	if(getRealValue() > other.getRealValue())
		return 1;
	return -1; //this object's real value < other object's real value
}
\end{lstlisting}
\end{solution}

\vskip 0.5 cm \question \textbf{Additional task }Complete the method \texttt{secondarySort} \vskip 0.5cm
The method \texttt{secondarySort} in class \texttt{FractionArrayService}, is a slight variation of insertion sort, and sorts a \texttt{Fraction} array by putting each item of array at the rightful place \emph{so far} in a secondary array. The original array should then be manipulated so that each item of the old array refers to the object the corresponding item of the secondary array refers to. This step has been left incomplete in the template and your job is to complete this part. You are trying to go through each item of the passed array (the array that needs to be sorted) (using index $i$) and updating its reference to the item at the same index in the secondary array.

\ifprintanswers
Re-referencing the array as \texttt{fractions = temp;} doesn't work as any re-referencing applied to a parameter array is ignored upon exiting the method. Hence, we need to re-reference each item of the array individually.
\begin{lstlisting}
for(int i=0; i<temp.length; i++)
	fractions[i] = temp[i];
\end{lstlisting}
\else
\newpage
\fi

\question \textbf{Additional task (ADVANCED): Graph validity} \vskip 0.5cm

In graph theory, it is possible to draw a (simple) graph only if,

\begin{enumerate}
\item if the sum of edges is even.
\item none of the vertices has a degree greater than or equal to the number of vertices.
\item the graph remains valid after removing all (say $k$) edges of the \emph{most connected} vertex (and one from other $k$ vertices each). While repeating this procedure, an unconnected vertex can be ignored. Only if we reach an empty graph by repeatedly applying this step, is it a valid graph. If we reach a scenario where the most connected vertex has degree $k$ and there aren't $k$ other vertices with non-zero degree left, the graph is invalid.
\end{enumerate}

For example, if the degree (number of edges with the vertex as an end-point) set for the vertices of a graph is \{3, 3, 3, 3, 3\}, we can see that the sum of degrees is 15 (not even), therefore it's not a valid graph.

If the degree (number of edges with the vertex as an end-point) set for the vertices of a graph is \{3, 3, 10, 4, 2\}, the third vertex's degree (10) is invalid (max degree for a graph with 5 vertices is 4), therefore it's not a valid graph.

If the degree (number of edges with the vertex as an end-point) set for the vertices of a graph is \{3, 3, 2, 4, 2\}, the first two aspects are ok (no violation). The sorted set is \{4,3,3,2,2\}, and after removing the 4 edge connected to the first vertex, the set becomes \{2,2,1,1\} (first vertex is disconnected and can be ignored. Repeating the process, the set becomes \{1,1,0,0\}, which is \{1,1\}, which becomes \{0,0\}, which is an empty graph. Hence the original graph is valid.

Similarly, if the set is \{4,3,2,2,1\}

\begin{align*}
\{4,3,2,2,1\}\\
reduced: \{0,2,1,1,0\}\\
sorted: \{2,1,1,0,0\}\\
reduced: \{0,0,0,0,0\}\\
valid \quad (empty \quad graph \quad reached)
\end{align*}

Another example - if the set is \{2,5,2,4,3,4\},

\begin{align*}
\{2,5,2,4,3,4\}\\
sorted: \{5,4,4,3,2,2\}\\
reduced: \{0,3,3,2,1,1\}\\
sorted: \{3,3,2,1,1,0\}\\
reduced: \{0,2,1,0,1,0\}\\
sorted: \{2,1,1,0,0,0\}\\
reduced: \{0,0,0,0,0,0\}\\
valid
\end{align*}

Last example - if the set is \{3,3,3,3\},

Similarly, if the set is \{2,5,2,5,3,4\},

\begin{align*}
\{5,5,4,3,2,2\}\\
reduced: \{0,4,3,2,1,1\}\\
invalid \quad (odd \quad sum \quad of \quad degrees)
\end{align*}

Write a method that when passed an array of degrees of the vertices of a graph, returns \texttt{true} if it's a valid graph, and \texttt{false} otherwise.

\ifprintanswers
Refer to GraphService.java in the solution project	
\else
\begin{solution}
\begin{lstlisting}
public static boolean isValidGraph(int[] degrees) {
}	
\end{lstlisting}
\end{solution}
\fi

\end{questions}
\end{document}
