<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Searching | COMP1010 - Fundamentals of Computer Science</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="Searching" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="/searching.html" />
<meta property="og:url" content="/searching.html" />
<meta property="og:site_name" content="COMP1010 - Fundamentals of Computer Science" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Searching" />
<script type="application/ld+json">
{"url":"/searching.html","@type":"WebPage","headline":"Searching","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="COMP1010 - Fundamentals of Computer Science" /></head>
<body><header class="site-header">

  <div class="wrapper">
    <a class="site-title" rel="author" href="/">COMP1010 - Fundamentals of Computer Science</a>
  </div>
</header>
<main class="page-content" aria-label="Content"><style>
  @media screen and (max-width: 700px) {
    .sidebar {
      position: absolute;
      margin: 0;
      overflow-x: hidden;
    }
  }

  @media screen and (min-width: 700px) {
    .sidebar {
      width: 25%;
      position: absolute;
      margin: 0;
      overflow-x: hidden;
    }
  }

  .sidebar a {
    color: black;
  }

  .sidebar ul {
    list-style-type: none;
  }

  .dropdown-content {
    display: none;
    position: relative;
    z-index: 1;
  }

  .dropdown-content a {
    display: block;
    color: black;
    background: white;
    text-align: left;
  }

  .show {display:block;}

  .wrapper {
    margin-left: 25%;
  }

</style>

<div class="sidebar">
  <ul>
        <li class="dropdown" data-name = "COMP1000"> COMP1000 ▼
          <ul id="COMP1000" class="dropdown-content"><a href="/transition_to_processing">Transition to Processing</a><a href="/primitive_operations">Primitive Operations</a><a href="/algorithms">Algorithms</a><a href="/variables">Variables</a><a href="/debugging_processing">Debugging in Processing</a><a href="/conditions">Conditions</a><a href="/loops">Loops</a><a href="/functions">Functions</a><a href="/scope">Scope</a><a href="/composite_data">Compound Data</a><a href="/reference_semantics">Reference Semantics</a><a href="/refactoring">Refactoring</a><a href="/design">Program Design</a></ul>
        </li>
      
        <li class="dropdown" data-name = "COMP1010"> COMP1010 ▼
          <ul id="COMP1010" class="dropdown-content"><a href="/transition_to_java">Transition to Java</a><a href="/debugging">Debugging in Java</a><a href="/unit_testing">Unit Testing</a><a href="/classes_types">Classes - Writing your own Types</a><a href="/classes_copies">Classes - Copying objects</a><a href="/classes_methods">Classes - Functions inside objects</a><a href="/classes_composition">Classes - Composition</a><a href="/classes_array_of_objects">Classes - Array of objects</a><a href="/classes_class_holding_array">Classes - Class holding array(s)</a><a href="/recursion_function_call">Recursion - What goes on during a function call</a><a href="/recursion">Recursion</a><a href="/recursion-strings">Recursion with String data</a><a href="/recursion-tail">Tail-optimized recursion</a><a href="/recursion-arrays">Recursion with arrays</a><a href="/lists">Lists</a><a href="/iteration">Iteration</a><a href="/listOfLists">List of Lists</a><a href="stacks_queues">Stacks and Queues</a><a href="/custom-built-arraylist">Custom-built ArrayList</a><a href="/recursive_data_structures_1">Recursive data structures - 1</a><a href="/recursive_data_structures_2">Recursive data structures - 2</a><a href="/searching">Searching</a></ul>
        </li>
      
        <li><a href="https://github.com/comp1010mq/comp1010mq.github.io">Edit (for staff)</a></li></ul>
</div>


<script>
  document.addEventListener('click', function (e) {
    var target = e.target;
    if (target.tagName && target.tagName.toLowerCase() == "li") {
      document.getElementById(target.dataset.name).classList.toggle("show");
    }
  });
</script>
<div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Searching</h1>
  </header>

  <div class="post-content">
    <details class="prereq">
  <summary>Assumed Knowledge</summary>

  <ul>
    <li><a href="./recursion">Recursion</a></li>
    <li><a href="./composite_data">Arrays</a></li>
  </ul>

</details>

<details class="outcomes">
  <summary>Learning Outcomes</summary>

  <ul>
    <li>Recognise the reasons binary search works</li>
    <li>Be able to trace a binary search on a sorted array</li>
    <li>Be able to write a binary search algorithm</li>
  </ul>

</details>

<h1 id="binary-search">Binary search</h1>

<p>In this section, we’ll learn a fast way of searching through data, under one assumption…</p>

<p><strong>The collection (array in our case) must be sorted</strong></p>

<p>We can always tweak the algorithm based on the order of sorting.</p>

<p>Before explaining things descriptively, how about a video to illustrate binary search, from our good friends at HackerRank.</p>

<p><strong>IMPORTANT!!!</strong></p>

<p>The implementation discussed is recursive. We haven’t covered recursion yet so only the first 2 minutes 40 seconds of the video are relevant.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/P3YID7liBug" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen=""></iframe>

<h2 id="the-game-is-on">The game is on!</h2>

<p>Lets say that we are playing the game that has the following rules.</p>

<ol>
  <li>Person A (henceforth named Alice) thinks of a number between 1 and 31 (including 1 and 31). Let this number be <code class="language-plaintext highlighter-rouge">target</code>.</li>
  <li>Person B (henceforth named Bob) tries to guess the number. Let Bob’s guess be <code class="language-plaintext highlighter-rouge">g</code>.</li>
  <li>Alice needs to tell Bob if,
    <ol>
      <li><code class="language-plaintext highlighter-rouge">target == g</code>, or,</li>
      <li><code class="language-plaintext highlighter-rouge">target &gt; g</code>, or,</li>
      <li><code class="language-plaintext highlighter-rouge">target &lt; g</code></li>
    </ol>
  </li>
  <li>Based on Alice’s response, Bob makes his next guess if required. That is, go to step 2.</li>
</ol>

<div class="task">
  <p>Does it make sense for the first guess to be 5?</p>
  <details class="solution">
    <summary>solution</summary>
    <p>No. Of course, you will find the target with any given guess with a small probability. Otherwise, in this case, if you are very lucky (4/31 probability), you’ll be left with 4 numbers to guess from. However, the chances are (26/31 probability) that you’ll be left with 26 numbers to guess from.</p>
  </details>
</div>

<div class="task">
  <p>What is a clever first guess?</p>
  <details class="solution">
    <summary>solution</summary>
    <p>The first clever guess would be 16 since either that <strong>is</strong> the target (1/31) or in either of the remaining cases, you are left with 15 numbers to guess from (either 1 to 15, or 16 to 31).</p>
  </details>
</div>

<blockquote>
  <p>If there are an even number of items (say, 10), then, excluding the middle
item, the left half will have one more or one less item than the right half.
This is ok :)</p>
</blockquote>

<p>The strategy explained in the last exercise is the same strategy we use to find a particular page in a book, where we “approximate” our guess within the remaining pages at each stage.</p>

<p>For those of you who may have used the dictionary, it’s again, the same strategy used to find a particular word in a dictionary.</p>

<h2 id="visualising-the-game">Visualising the game</h2>

<p>Assume the numbers in contention being in green. Initially all the numbers are in contention</p>

<blockquote>
  <p><span style="color:green">1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31</span></p>
</blockquote>

<p>Guess 1: 16. Feedback: target is higher than 16</p>

<blockquote>
  <p><span style="color:red">1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,</span><span style="color:green"> 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31</span></p>
</blockquote>

<p>Guess 2: 24. Feedback: target is lower than 24</p>

<blockquote>
  <p><span style="color:red">1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,</span><span style="color:green"> 17, 18, 19, 20, 21, 22, 23,</span><span style="color:red"> 24, 25, 26, 27, 28, 29, 30, 31</span></p>
</blockquote>

<p>Guess 3: 20. Feedback: target is lower than 20</p>

<blockquote>
  <p><span style="color:red">1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,</span><span style="color:green"> 17, 18, 19,</span><span style="color:red"> 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31</span></p>
</blockquote>

<p>Guess 4: 18. Feedback: target is higher than 18</p>

<blockquote>
  <p><span style="color:red">1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,</span><span style="color:green"> 19,</span><span style="color:red"> 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31</span></p>
</blockquote>

<p>Guess 5: 19. Feedback: target equals 19 - <strong>FOUND!</strong></p>

<h2 id="coding-the-game">Coding the game</h2>

<p>Say the array <code class="language-plaintext highlighter-rouge">arr</code> is:</p>

<blockquote>
  <p><span style="color:red">20, 60, 40, 10, 0, 30, 70, 50</span></p>
</blockquote>

<p>The first thing we need to do is to sort it. Depending on the order, the rest of the implementation will be tweaked. Say we sort it in ascending order as:</p>

<blockquote>
  <p><span style="color:green">0, 10, 20, 30, 40, 50, 60</span></p>
</blockquote>

<p>Let us say that <code class="language-plaintext highlighter-rouge">target = 40</code></p>

<p>Our first guess would be <code class="language-plaintext highlighter-rouge">30</code> as it would split the array down the middle.
Upon comparing <code class="language-plaintext highlighter-rouge">target</code> with the guess, we can see that if present, <code class="language-plaintext highlighter-rouge">target</code> is in the right half.</p>

<p>We update our search space by updating parameters <code class="language-plaintext highlighter-rouge">first</code> and <code class="language-plaintext highlighter-rouge">last</code> that hold first and last indices of the search space, respectively. The original values being:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
</code></pre></div></div>

<p>Index of the middle item is computed at each iteration as:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">median</span> <span class="o">=</span> <span class="o">(</span><span class="n">first</span><span class="o">+</span><span class="n">last</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
</code></pre></div></div>

<p>The three scenarios we have are:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">target == arr[median]</code>:
    <ul>
      <li>return <code class="language-plaintext highlighter-rouge">median</code> immediately</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">target &gt; arr[median]</code>:
    <ul>
      <li>first = median + 1 (to reflect searching in the right half)</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">target &lt; arr[median]</code>:
    <ul>
      <li>last = median - 1 (to reflect searching in the left half)</li>
    </ul>
  </li>
</ol>

<h3 id="until-when-should-we-do-this">Until when should we do this?</h3>

<p>We do this as long as search space is not empty. If <code class="language-plaintext highlighter-rouge">first</code> becomes more than <code class="language-plaintext highlighter-rouge">last</code> it means the starting point of the search space is AFTER ending point of the search space which isn’t possible. So the expression to carry on is:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span><span class="n">first</span> <span class="o">&lt;=</span> <span class="n">last</span><span class="o">)</span>
</code></pre></div></div>

<p>What happens when <code class="language-plaintext highlighter-rouge">first &gt; last</code> and the expression is no longer true? We have searched everywhere and not found the target. So we can return -1 (standard not-found index).</p>

<h3 id="putting-it-all-together">Putting it all together</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">binarySearch</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
	<span class="k">while</span><span class="o">(</span><span class="n">first</span> <span class="o">&lt;=</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">median</span> <span class="o">=</span> <span class="o">(</span><span class="n">first</span><span class="o">+</span><span class="n">last</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
		<span class="k">if</span><span class="o">(</span><span class="n">target</span> <span class="o">==</span> <span class="n">arr</span><span class="o">[</span><span class="n">median</span><span class="o">])</span>
			<span class="k">return</span> <span class="n">median</span><span class="o">;</span>
		<span class="c1">//we reach here only if target != arr[median]</span>
		<span class="k">if</span><span class="o">(</span><span class="n">target</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">median</span><span class="o">])</span>
			<span class="n">first</span> <span class="o">=</span> <span class="n">median</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
		<span class="k">else</span>
			<span class="n">last</span> <span class="o">=</span> <span class="n">median</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="binary-search-performance">Binary search performance</h2>

<p>Let number of items at start be <code class="language-plaintext highlighter-rouge">n</code>. For simplicity, assume <code class="language-plaintext highlighter-rouge">n</code> is a power of 2, like 1, 2, 4, 8, 16, 32 and so on. We write this as <code class="language-plaintext highlighter-rouge">n</code> = 2<sup>k</sup>.</p>

<p>Just like square is the inverse of square root, logarithm is the inverse of power.</p>

<p>n = 2<sup>k</sup></p>

<p>is also written as:</p>

<p>k = log<sub>2</sub>(n)</p>

<h3 id="best-case-scenario">Best case scenario</h3>

<p>The best case is that the middle item is the target. In the best case, it takes only one iteration to find the target.</p>

<blockquote>
  <p>Number of iterations in best case: 1</p>
</blockquote>

<h3 id="worst-case-scenario">Worst case scenario</h3>

<p>The worst case is that the item doesn’t exist in the array. In this case, we keep halving the search space.</p>

<ul>
  <li>After iteration 1: 2<sup>k</sup> to 2<sup>k-1</sup></li>
  <li>After iteration 2: 2<sup>k-1</sup> to 2<sup>k-1</sup></li>
  <li>After iteration 3: 2<sup>k-2</sup> to 2<sup>k-1</sup></li>
  <li>…</li>
  <li>After iteration k: 2<sup>k-(k-1)</sup> or 2<sup>1</sup> to 2<sup>k-k</sup> or 2<sup>0</sup></li>
</ul>

<p>After <code class="language-plaintext highlighter-rouge">k</code> iterations, we’ll reach our last item and after that the loop terminates as <code class="language-plaintext highlighter-rouge">first &gt; last</code>.</p>

<p>This gives us the number of iterations in the worst case as <code class="language-plaintext highlighter-rouge">k</code>, or,</p>

<blockquote>
  <p>Number of iterations in worst case: <strong>log<sub>2</sub>(n)</strong></p>
</blockquote>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">COMP1010 - Fundamentals of Computer Science</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">COMP1010 - Fundamentals of Computer Science</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
